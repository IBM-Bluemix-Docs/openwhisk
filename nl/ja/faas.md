---

copyright:
  years: 2017, 2019
lastupdated: "2019-05-15"

keywords: functions compared, openwhisk, architecture, limitless

subcollection: cloud-functions

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:pre: .pre}
{:table: .aria-labeledby="caption"}
{:codeblock: .codeblock}
{:tip: .tip}
{:note: .note}
{:important: .important}
{:deprecated: .deprecated}
{:download: .download}
{:gif: data-image-type='gif'}

# Function as a Service のアーキテクチャー
{: #faas}

{{site.data.keyword.openwhisk}} は、ハイ・スケーラブルなサーバーレス環境の OpenWhisk を提供します。 {{site.data.keyword.openwhisk_short}} のサーバーレス・アーキテクチャーおよびコスト効率が高いコンピューティングをその他のアーキテクチャー・モデルと比較できます。
{: shortdesc}

## サーバーレスに移行する理由

- インフラストラクチャーのオーバーヘッドがない
- 保守が最小限
- コスト効率
- スケーリングが簡単
- 速い!


## OpenWhisk アーキテクチャーの比較
{: #faas_architecture}

以下の OpenWhisk アーキテクチャーの比較を示します。

1. **Function as a Service (FaaS)** on [{{site.data.keyword.openwhisk_short}}](https://cloud.ibm.com/openwhisk)。 IBM は、管理された OpenWhisk を提供する唯一のベンダーです。 FaaS プラットフォームを使用したサーバーレス・プログラミング・モデルの入門としては、[Martin Fowler のブログ](https://martinfowler.com/articles/serverless.html)が適しており、サーバーレス設計で OpenWhisk を実行する[ユース・ケース](/docs/openwhisk?topic=cloud-functions-use_cases)を確認できます。

2. **Infrastructure as a Service (IaaS)** で OpenWhisk ユーザー作成プログラム (RYO) を使用。 OpenWhisk を Apache Incubation Project からダウンロードし、それを [{{site.data.keyword.Bluemix_notm}} IaaS](https://cloud.ibm.com/catalog/?category=devices) 上で実行できます。

3. **Platform as a Service (PaaS)** を管理対象アプリケーション・ランタイムとして。 {{site.data.keyword.Bluemix_notm}} Foundry 実装で管理された [Liberty for Java](https://cloud.ibm.com/catalog/starters/liberty-for-java) ランタイムがその良い例です。

4. **Container as a Service (CaaS)** を管理対象コンテナー環境として。 [{{site.data.keyword.containerlong_notm}}](/docs/containers?topic=containers-getting-started#container_index) が良い例です。

5. **Infrastructure as a Service (IaaS)** で Java EE ランタイムを使用。 [{{site.data.keyword.Bluemix_notm}} 上の WebSphere Application Server VM](https://cloud.ibm.com/catalog/services/websphere-application-server) が良い例です。

以下の表は、アプリケーションを作成および運用する開発者の観点から、各アーキテクチャーの要素を比較したものです。


| トピック | (1) FaaS on {{site.data.keyword.openwhisk_short}} | (2) IaaS と OpenWhisk RYO | (3) PaaS | (4) CaaS | (5) IaaS と Java EE |
| --- | --- | --- | --- | --- | --- |
|	アプリケーション単位	|	単一関数 (通常、JavaScript、Swift、または Docker コンテナーの小さなコード・ブロック)。1 KB を下回る場合も上回る場合もあります。 通常は数 KB 以下です。	|	列 (1) と同じ	|	使用されるランタイムによって異なります。 EAR ファイルまたは WAR ファイル、またはその他の言語固有のアプリケーション・バンドル。通常、1 つのバンドル内に多数のサービスがあり比較的大きくなります (KB サイズ、さらには MB サイズの場合もあります)。一方で、サービスが 1 つの小さいものもあります。	|	デプロイメントの単位は Docker コンテナーです。	|	EAR ファイルまたは WAR ファイルとその他の依存関係を使用したアプリケーション・サーバーを含む VM。通常は GB のサイズです。	|
|	リソースのフットプリント	|	エンド・ユーザーは、メモリー、CPU、その他のリソースについて費用を支払うことも配慮することもありません。 アクションにいくらかのフットプリントはありますが、ユーザーがそれを心配する必要はありません。	|	大。 エンド・ユーザーは必ず IaaS 環境をまずプロビジョンしてから、その上に OpenWhisk をインストールして構成する必要があります。	|	小。 エンド・ユーザーはアプリを実行するためのメモリーと CPU について費用を支払いますが、実行中でないアプリについては費用は発生しません。	|	小から中	|	大。 エンド・ユーザーは、アプリ実行中には、ディスク・ストレージ、メモリー、CPU、および場合によってはその他のコンポーネントについても費用を支払う必要があります。 アプリ停止時には、ストレージ・コストのみが発生します。	|
|	インストールとセットアップ	|	不要	|	困難。エンド・ユーザーがすべてを行います。	|	不要	|	中程度。ハードウェア、ネットワーキング、OS、コンテナー管理ツールは CaaS ベンダーが、イメージ、接続、インスタンスはエンド・ユーザーが提供します。	|	困難。ハードウェア、ネットワーキング、OS、初期 Java EE インストールはベンダーが、追加の構成、クラスタリング、スケーリングはエンド・ユーザーが提供します。	|
|	プロビジョニングの時間	|	数ミリ秒	|	列 (4) と (5) を参照	|	数分	|	数分	|	数時間	|
|	進行中の管理	|	なし	|	困難	|	なし	|	中程度	|	困難	|
|	弾力性に優れたスケーリング	|	各アクションは常に負荷に応じて即時かつ本質的にスケーリングされます。 VM および他のリソースを事前にプロビジョンする必要はありません。	|	提供されません。エンド・ユーザーが、IaaS でコンピュート・キャパシティーを提供し、VM のスケーリングを管理する必要があります。 VM がいったんスケーリングされると、OpenWhisk が自動的にアクションをスケーリングしますが、リソースは事前にプロビジョン済みでなければなりません。	|	自動ですが、スケーリングには時間がかかります。 負荷が増加している間、ユーザーがスケーリング・アクションの完了を数分間待つ可能性があります。 自動スケーリングには、入念な調整が必要です。	|	自動ですが、スケーリングには時間がかかります。 負荷が増加している間、ユーザーがスケーリング・アクションの完了を数分間待つ可能性があります。 自動スケーリングには、入念な調整が必要です。	|	提供されません	|
|	キャパシティー・プランニング	|	不要。 必要なキャパシティーを FaaS が自動的に提供します。	|	事前に十分なキャパシティーをプロビジョンするか、スクリプト化する必要があります。	|	ある程度のキャパシティー・プランニングが必要ですが、ある程度の自動のキャパシティー増強が提供されます。	|	ある程度のキャパシティー・プランニングが必要ですが、ある程度の自動のキャパシティー増強が提供されます。	|	ピーク時のワークロードを処理できるだけの十分なキャパシティーを静的にプロビジョンする必要があります。	|
|	持続的な接続および状態	|	限定的。コンテナー・キャッシングの場合を除き、持続的な接続を保持できません。 一般的に、状態は外部リソースで保持される必要があります。	|	列 (1) と同じ	|	サポートされます。オープン・ソケットまたは接続を長時間保持することができ、呼び出しと呼び出しの間はメモリーに状態を保管できます。	|	サポートされます。オープン・ソケットまたは接続を長時間保持することができ、呼び出しと呼び出しの間はメモリーに状態を保管できます。	|	サポートされます。オープン・ソケットまたは接続を長時間保持することができ、呼び出しと呼び出しの間はメモリーに状態を保管できます。	|
|	保守	|	なし。スタック全体が IBM によって管理されます。	|	かなり大。ターゲット環境に応じて、ユーザーによるハードウェア、ネットワーキング、OS、ストレージ、DB のプロビジョン、OpenWhisk のインストールおよび保守などが必要です。	|	なし。スタック全体がベンダーによって管理されます。	|	かなり大。ユーザーがカスタム・イメージの作成と保守、コンテナーのデプロイと管理、コンテナー間の接続の管理などを行う必要があります。	|	かなり大。ユーザーが VM を割り振り、Java EE サーバーを個々に管理してスケーリングする必要があります。	|
|	高可用性 (HA) と災害復旧 (DR)	|	内在 / 追加コストはありません	|	ユーザー作成プログラム (RYO) 	|	利用には追加料金が必要です。	|	失敗したコンテナーを自動的に再始動することができます。	|	半自動で、利用には追加料金が必要です。 VM を自動的にフェイルオーバーすることができます。	|
|	セキュリティー	|	ベンダーによって提供される	|	ユーザー作成プログラム (RYO)	|	RYO とベンダー提供の混合	|	RYO とベンダー提供の混合	|	ユーザー作成プログラム (RYO)	|
|	開発者の速度	|	最速	|	最速	|	最速	|	平均	|	低速	|
|	リソース使用状況 (アイドルであっても支払いが必要なリソース)	|	リソースは、要求時にのみ起動されるので、アイドルになることはありません。 ワークロードがない場合、コストは発生せず、リソース割り振りも発生しません。	|	このオプションは IaaS または CaaS を使用するため、列 (4) および (5) と同様の考慮事項が適用されます。	|	一部のリソースがアイドルになる可能性があり、アイドル状態のリソースをなくすのに自動スケーリングが役立ちます。 多数の実行中インスタンスが常時存在する必要があり、これらの使用はキャパシティーの 50 % に満たないことが多くあります。 停止済みのインスタンスにコストはかかりません。	|	列 (3) と同様	|	一部のリソースがアイドルになる可能性がありますが、自動スケーリングはサポートされません。 いくつかの実行中インスタンスが常時存在する必要があり、これらの使用はキャパシティーの 50 % に満たないことが多くあります。 停止済みのインスタンスに、ストレージのコストが発生する場合があります。	|
|	成熟度	|	早期の成熟度	|	早期の成熟度	|	早期の成熟度	|	中程度の成熟度	|	高い成熟度	|
|	リソース制限	|	[いくつかの制限があります](/docs/openwhisk?topic=cloud-functions-limits#limits_syslimits)。	|	割り振られたリソースによって異なります。	|	なし	|	なし	|	なし	|
|	使用頻度の低いサービスの待ち時間	|	頻度の低い要求では、最初は何秒かの応答時間がかかることがありますが、その後の要求ではミリ秒の範囲にとどまります。	|	場合によって異なる	|	小	|	小	|	小。システムに十分なリソースがあることが前提	|
|	最適なアプリケーション・タイプ	|	イベント処理、IoT、モバイル・バックエンド、マイクロサービス。 モノリシック・アプリケーションには明らかに不適です。 [ユース・ケース](/docs/openwhisk?topic=cloud-functions-use_cases)を参照	|	列 (1) と同じですが、ユーザーが 非 IBM Cloud で、またはオンプレミスで実行する必要がある場合です。	|	24 時間 365 日の作業負荷がある Web アプリケーション、接続を長期間オープンにしておく必要があるステートフル・サービス。 マイクロサービスまたはモノリシック・アプリケーションの実行に使用できます。	|	マイクロサービス・アプリケーションに最適。	|	オンプレミスからクラウドにマイグレーションされた従来型のエンタープライズ・アプリケーション。 モノリシック・アプリケーションに最適。	|
|	課金の細分度と請求処理	|	[100 ミリ秒のブロックごと](https://cloud.ibm.com/openwhisk/learn/pricing)	|	実装によって異なる。IaaS または CaaS が使用されている場合、同様の考慮事項が適用されます。列 (4) および (5) を参照。	|	通常は、一括にしたリソース (CPU + メモリー + 一定のディスク・スペース) に対して時間単位 (まれに、分単位) で課金されます。	|	列 (3) と同様	|	列 (3) と同様	|
|	総所有コスト (TCO)	|	優位点として、アプリケーションのコストが他の選択肢よりも桁違いに低くなる可能性があります。 リソースが自動的にスケーリングされるため、オーバープロビジョニングは発生しません。	|	クラウド・デプロイメントでは、OpenWhisk FaaS よりコストが高くなる可能性が大きいですが、オンプレミス・デプロイメントでは、従来型のアーキテクチャーより安くなる可能性があります。	|	比較的低い。ユーザーはリソースをプロビジョンしたり管理したりする必要がなく、アプリケーション開発に集中できます。 サーバーレスに比べてある程度のオーバープロビジョニングがあります。	|	中程度。ユーザーはコンテナーおよびアプリケーションをプロビジョンして管理する必要があり、サーバーレスまたは PaaS と比べて一定レベルのオーバープロビジョニングが発生することがあります。	|	比較的高い。レガシー・アプリケーションをクラウド・ネイティブ・モデルへマイグレーションすることに非常にコストがかかる可能性があることを考えると、そうしたアプリ向けの実現可能で経済的な選択肢になり得ます。	|

## コストについての考慮事項
{: #faas_cost}

テスト、ステージング、負荷テスト、およびその他の環境のためのインフラストラクチャーには、コストがかかります。 セットアップに時間がかかるうえ、通常は 24 時間 365 日稼働することになるので、十分に活用されないことも多く、大量のキャパシティーを消費します。 サーバーレス・アーキテクチャーを使用すると、いくつ環境があろうと、環境のコストは、定義されている環境の数でなく、負荷に基づいて生成されます。
{: shortdesc}

サーバーレス・アプリケーションのコストを見積もるには、[料金カリキュレーター ![外部リンク・アイコン](../icons/launch-glyph.svg "外部リンク・アイコン")](https://cloud.ibm.com/openwhisk/learn/pricing) を使用できます。

### 無限のキャパシティー
{: #faas_capacity}

従来のアーキテクチャーでは、各サービスはそれぞれに割り振られた容量を消費し、ユーザーは容量使用量に応じて請求されます。 {{site.data.keyword.openwhisk_short}} のサーバーレス・アーキテクチャーでは、マイクロサービス・アーキテクチャーの細分度に対する制約が削減されます。

{{site.data.keyword.openwhisk_short}} を使用していないとき、コストは発生しません。 HTTP 呼び出し、データベース状態変更、または、コードの実行をトリガーするその他のタイプのイベントがあると、コードが実行されます。 課金は、100 ms 単位に丸められた、実行時間のミリ秒単位で行われます。VM が有益な作業をしていたかどうかに関係ない VM 利用の時間単位で課金されることはありません。 イベントがコンシュームされた場合にのみ支払いを行い、環境の数に基づいて支払いを行うわけではないので、アプリを 100 個、1000 個、またはさらに多くのマイクロサービスへと分割できます。

### 任意の地域でのアクションの実行
{: #faas_region}

従来のアーキテクチャーでは、実行対象の各地域でコードが実行される必要があり、その地域のインフラストラクチャーにも料金がかかります。 {{site.data.keyword.openwhisk_short}} では、追加のコストなしに任意の地域にアクションをデプロイし、そこで実行できるようになります。 従来のコスト制限なしで、コードの可用性と回復力を高めることができます。

### 仕様での冗長性
{: #faas_redundancy}

従来のアーキテクチャーでは、アプリケーションに冗長性が必要です。 サーバーレス・アプリケーションは、仕様がステートレスかつ要求イベント・ドリブンであるため、{{site.data.keyword.openwhisk_short}} では、プロセスを高可用性 (HA) にする必要はありません。 冗長性を明示的に作成する必要をなくすことで、サーバーレス・アプリケーションのステートレスな性質により、インフラストラクチャーのコストが大幅に削減されます。

